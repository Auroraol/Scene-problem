- **秒杀系统设计**：并发量大、数据库承受压力，如何防止超卖？
- **短链接生成**：分布式ID生成器和62进制的使用方法。
- **高并发红包系统**：事务严格要求下如何实现并发控制？
- **分布式ID生成策略**：常见方法及其优缺点。
- **分布式限流**：固定窗口、滑动窗口、漏桶、令牌桶算法的实现与选择。
- **分布式定时任务**：任务轮询与抢占排队方案的应用。
- **新浪微博推送**：复杂关系下的大量数据处理策略。
- **大文件有限内存排序**：外归并排序和位图排序的具体操作。



# 秒杀系统设计

## 流程图

![4b92e2dee189e18d2499507e10548986](%E5%9C%BA%E6%99%AF%E9%A2%98.assets/4b92e2dee189e18d2499507e10548986-17451538184835.svg)

## 限流器

因为秒杀活动瞬时并发量很高，商品数量远低于参与人数，引用限流器的目的也就是为了把大部分的流量阻挡在外。关于限流器应当放进来多少流量，可以再秒杀开始前实时统计参与人数，再根据商品数量计算一个比例。

## 队列

通常可以使用像kafka,rocketmq等消息中间件作为队列，队列可以削峰，避免瞬时并发访问量流入到后端服务。

## 缓存

经过限流器后其实放进来的流量就少了很多，但对于如果参与秒杀活动的商品是一种大库存的，那么这个流量可能也是比较大的，之后的队列可以削峰，有效防止后端服务过载。

缓存在次设计中承担两种角色：

+ 其存放下单结果，承接用户的结果轮询探测。
+ 进行库存的查验和扣减，当然实际当中可以做隔离。

上述设计中缓存服务如果不可用，那么就无法下单，实际可能库存还有，但用户无法继续下单。因此针对这种情况，以redis为例，可通过主从加哨兵模式保证缓存的高可用。从这里就可以看出，因为主从这种机制，很容易出现主从数据不一致，也就是说从缓存这层看，商品可能会超卖。其实无需担心这些，因为到后面的库存系统处理时，会再次做库存的查验，不会出现超卖。缓存的这种数据不一致，仅会使得流入下游的流量多一些而已，加上上游已经采用队列将请求异步化，因此并不会对下游带来很大的冲击。



当缓存完全不可用，进行人工或自动恢复时，库存的初始化可以根据商品的初始容量，以及产生的订单，计算出商品当前库存量。(此时的库存量并不严格要求一致，因为库存系统有做把关)。

## 订单处理

缓存中的库存扣减成功后，便创建订单，但在预扣减实际的库存前，订单对用户是不可见的，可以结合事务消息来保证订单和库存的一致性。

## 库存处理

库存系统接收到预扣减库存消息后，同样需要进行库存的查验。如果库存不足，则下单失败。库存充足，则进行库存锁定，生成预扣减记录，使用数据库乐观锁避免商品超卖，其实这里是防止超卖做的最后的一层把关。库存的实际扣减待用户支付完成后进行，实际上能够走到支付环节的用户已经很少了，系统是可以承受这个流量的。



对于上述所设计所涉及到的系统都应当是集群化的，毕竟巧妇难为无米之炊。大规模的集群其吞吐量要比更小规模的要高，即使这种吞吐量不是限行增长的，这种增长也是可观的。



除此之外，高并发的场景，我们还应当应用降级，熔断等机制保护系统。比如对于非核心流程的业务，在秒杀活动期间可以进行降级处理，腾出更多的资源服务于核心业务。对于服务所依赖外部服务的异常，同样可以结合降级或熔断机制来保护服务自身。 



对于弱依赖的服务，在流程上我们还可以异步化。比如使用消息中间件，除了削峰之外，亦能够增加系统的吞吐量。



  恶意下单

  

上述设计中并没有关于恶意下单的流程。恶意下单是指恶意用户下单后不付款，占用商品库存。除了可以通过平台的风控系统，比如黑名单等机制做拦截外，还可以在下单流程上做些工作。



用户成功下单后，我们可以发送一个延时消息，这个时间就是锁定库存的时间(比如5分钟)，锁定时间到期后用户未付款，则订单作废，增加缓存中的库存。延时消息可以使用RocketMq


