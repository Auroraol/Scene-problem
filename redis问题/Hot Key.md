# 热点 Key

> **在 Redis 中，访问频率高的 key，称为热点 key。**

## Hot Key 出现的场景

**Hot Key 的主要场景：**

- 电商商品秒杀、活动积分竞拍、热点惊爆新闻等
  - 双十一、618 的商品秒杀，造成短时间内某宝或者夕夕上的爆款商品被浏览百万次
  - 某博上的惊爆新闻等引发大量围观，造成一个 redis 缓存信息被群蜂冲击，热点 Key 问题造成服务雪崩
- 请求分片集中，调度不合理，超过单台 Redis 服务的吞吐瓶颈和性能极限
  + Redis 缓存会采用分片进行数据管理和性能提升。服务端对数据进行访问时，会通过一些负载均衡策略进行访问平衡，但是类似 hash 计算，也有可能会落入同一台 redis 服务器，如果瞬间访问量过大，超过主机吞吐极限时，就会导致热点 Key 现象发生。
- 突发事件
  + 系统故障、黑客攻击、自然灾害等，导致大量的用户访问某个特定的 Redis Key。

## Hot Key 产生的危害

在 Redis 中，Hot Key 的危害：

1. **单点访问频率过高**：Hot Key 会导致大部分的访问流量集中在某一个 Redis 实例上，使得该实例的负载过高，可能会导致该实例崩溃，影响线上业务。
2. **分片服务瘫痪**：Redis 集群会分很多个分片，每个分片有其要处理的数据范围。当某一个分片被频繁请求，该分片服务就可能会瘫痪。
3. **Redis 分布式集群优势弱化**：如果请求不够均衡，过于单点，那么 Redis 分布式集群的优势也必然被弱化。
4. **可能造成资损**：在极端场景下，容易发生边界数据处理不及时，在订单等场景下，可能造成资损。
5. **引发缓存击穿**：如果缓存请求不到，就会去请求数据库。如果请求过于集中，Redis 承载不了，就会有大量请求打到数据库。此时，可能引发数据库服务瘫痪，进而引发系统雪崩。
6. **CPU 占用高，影响其他服务**：单个分片 CPU 占用率过高，其他分片无法拥有 CPU 资源，从而被影响。

## 监测并分析 Hot Key

1. **容量评估**
   联网的业务场景具备一定规律的，根据一些决策树，结合业务场景，可以分析出哪些是热点场景，哪些信息可能是 Hot Ke，比如
   - 双 11、618 的秒杀商品、积分竞拍商品，那么这个商品信息、竞拍/购买操作都是热操作，关联的 Redis 信息都可能是 HotKey。
   - 比如突发的新闻热点，依照画像识别，数据不断攀升，在某个时间点有概率会成为 HotKey 新闻，需要提前干预
2. **业务埋点上报**
   这种方式 low 一点，需要切入我们的业务代码进行埋点，加入对 Redis Key 调用次数的统计，并把收集到的数据上报到统一的服务进行聚合计算，缺点就是对业务有一定的侵入性。
3. **使用 Redis 自带命令**
   可以使用 INFO 命令获取关于 Redis 服务器的各种信息，包括键的读写次数。通过定期执行 INFO 命令并分析返回的信息，可以判断哪些键是 Hot Key。另外，Redis 4.0.3 提供了 redis-cli 的热点 key 发现功能，执行 redis-cli 时加上–hotkeys 选项即可。
4. **使用第三方工具**
   如 redis-faina 是一个现成的分析工具，可以用来分析 Redis 中的 Hot Key。
5. **使用 Redis 监控工具**
   如使用 Redis Exporter 可以导出 Redis 服务器的各种信息，包括键的访问频率等，方便进行监控和分析。

## 解决方案

### **缓存预热**

既然是可预见的 HotKey，那么缓存预热是一个好办法，比如双 11 开启活动前，热点新闻爆出之后，预先加载一些热 key 的数据到缓存中，以减少对数据库的冲击
![image](Hot%20Key.assets/167509-20231223115011842-634147137.png)

### **缓存击穿处理**

#### 短暂降级之备选缓存

![image](Hot%20Key.assets/167509-20231223120118354-136174424.png)

#### 短暂降级之客户端缓存（Redis 6.0）

![image](Hot%20Key.assets/167509-20231223120143124-1785372256.png)

#### 短暂降级之空初始值

![image](Hot%20Key.assets/167509-20231223120154950-1399271219.png)

### **分布式缓存**

通过分布式缓存系统来分散请求负载，避免单一节点压力过大。现在的 Redis 高可用部署模式最常见的是主从和 Cluster，无论哪一种，都会降低单点带来的影响。
![image](Hot%20Key.assets/167509-20231223142825505-1209233678.png)

### 破解过期时间一致性问题

缓存的建立过程都是散列的，但是如果长时间静待都会被逐渐释放。
比如钉钉、飞书的办公场景，遇到夜晚低峰期、周末节假日，缓存Key被逐步释放之后。很容易在第二个工作日的早高峰造成大量创建缓存，流量井喷。
解决方案除了前面我们提到的缓存预热之外，错峰过期时间也是常规操作。
可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。
随机值我们团队的做法是：n * 3/4 + n * random() 。所以，比如你原本计划对一个缓存建立的过期时间为8小时，那就是6小时 + 0~2小时的随机值。这样保证了均匀分布在 6~8小时之间。

### 过滤垃圾请求

一般情况下，我们取数先从缓存中`Get Key`，不存在的时候再从数据库中去获取，但这很容易给攻击者提供漏洞。

他可以疯狂模拟一些不存在的`Key`，让你进入数据库去取数，这样就可以拖垮你的数据库，实现击溃你系统的目的。

有效的办法是在服务层先判断这个`Key`的是否符合标准（比如滴滴的订单数据缓存包含时间戳+用户ID的序列化），这样可以过滤一部分无效攻击。

但是如果他能够破解你key的规则，依旧可以钻漏洞。你可以在缓存层上加一层过滤器，帮你Filter掉那些不合理的攻击。
![image](Hot%20Key.assets/167509-20240317080521787-21349424.png)

### 消息队列和削峰

如果一个缓存不存在（不存在、过期、被误删都有可能），但是同时有千万请求投奔过来。
这时候关心是不是及时拿回正确数据已经不重要了，保住你的缓存和数据库不被击穿才是关键。
队列的目的是让并行变成串行，这一定程度上降低系统处理用户请求的吞吐能力，但是却能很好的缓解你服务的压力和风险。
![image](Hot%20Key.assets/167509-20240317084539764-1058552710.png)
如上图：第一个请求B从数据库中取，后面的C、A就是从缓存服务中取了，压力变小很多。

### 限流策略

可以使用 Hystrix(基于 Spring 框架的分布式系统的熔断器)进行限流 + 降级 ，比如一下子来了 1W 个请求，不是当前系统的吞吐能力能够承受的，假设单秒 TPS 的能力只能是 5000 个，那么剩余的 5000 请求就可以走限流逻辑。
可以设置一些默认值，然后调用我们自己降级逻辑去 FallBack，保护最后的 MySQL 不会被大量的请求挂起。 

除了 Hystrix 之外，阿里的 Sentinel 和 Google 的 RateLimiter 都是不错的选择。

**Sentinel 漏桶算法**
![image](Hot%20Key.assets/167509-20240317091407977-1084932926.png)
**RateLimiter 令牌桶算法**
![image](Hot%20Key.assets/167509-20240317091416525-1984322868.png)

### 高可用集群和自动扩缩容

集群模式和自动扩缩容模式从服务到缓存到数据层都应该具备，否则无法根据流量来进行弹性伸缩，保持高可用。
如下图， 蓝色部件是扩容的部分，每一分层都有自己的动态扩容机制。
![image-20250421205747692](Hot%20Key.assets/image-20250421205747692.png)

## 热点 Key 的发现及处理整体流程

![image.png](Hot%20Key.assets/1603878066291-886fc37c-49ff-42c2-9ff2-e8d836447f4c.webp)

**热点 key 的访问，最终的目的是希望热点 key 缓存在应用自身的本地内存中，这样就不会再产生到远程缓存的网络 IO。**

上图解释：

1. 应用程序访问远程缓存的 SDK 改造，拦截访问操作，封装成消息，发送到 kafka，kafka 本身除了是一款高性能，高可靠，实时性好的消息中间件之外，还是流数据处理平台，因此可以借助其生态圈中实时流计算框架，诸如 storm, spark 等来统计和发现热点 key。发现热点 key 之后，将其存储到 zookeeper(或具有类似功能的组件)上，zookeeper 本身是分布式协调框架，其本身已实现高可靠性，借助其 watch 机制，应用程序监听，一旦产生热点 key，zookeeper 会通知到应用程序，收到通知之后便可以把热点 key 的数据缓存到本地内存中。
2. 热点 key 缓存在应用自身的本地内存中
3. 对于热点 key, 还可以将热点 key 存储到具有更好配置，更强性能的节点上，也就是图中的 [热点 key 迁移服务]。

# 参考

+ [架构与思维：如何应对Redis热Key](https://www.cnblogs.com/wzh2010/p/17904849.html)
